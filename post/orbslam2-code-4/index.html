<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Offliner&#39;s Blog - ORBSLAM2 程式碼解析 - Frame </title>
    
    
    <meta content="ORBSLAM2, code analysis, ORBSLAM2 程式碼解析" name="keywords">
    
    <meta content="Offliner&#39;s Blog - ORBSLAM2 Code Analysis - Frame" name="description">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    
        <link rel="icon" href="/images/dino.png">
    

    

    
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-WFQ2VM3C00"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments)};
          gtag('js', new Date());
          gtag('config', 'G-WFQ2VM3C00');
        </script>
    

    
    
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            extensions: ["tex2jax.js"],
            jax: ["input/TeX", "output/HTML-CSS"],
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                processEscapes: true
            },
            "HTML-CSS": { availableFonts: ["TeX"] }
        });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>
    

    <link rel="stylesheet" href="/layui/css/layui.css">
    <link rel="stylesheet" href="/self/css/default.css">
    <script src=" /layui/layui.js"></script>

    <link rel="stylesheet" async href="/self/css/markdown.min.css">
    <link rel="stylesheet" async href="/self/css/gallery.css">
    
    
    

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous">
    <script async src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.0/lazysizes.min.js" integrity="sha256-h2tMEmhemR2IN4wbbdNjj9LaDIjzwk2hralQwfJmBOE=" crossorigin="anonymous"></script></head>

<body>
    
    <header class="layui-header layui-bg-cyan">

    
        <a href=""><img src="/images/Offliner.png" class="layui-nav-img" style="margin-left:10px;margin-top:-10px"></a>
    
    
    <a class="nav-self-logo" href="/">
        Offliner&#39;s Blog
    </a>

    <ul class="layui-nav layui-layout-right layui-bg-cyan" lay-filter="">
        
        
        <li class="layui-nav-item" id="nav_big"><a href="/post/">Posts</a></li>
        

        
            
                <li class="layui-nav-item" id="nav_big"><a href="/zone/">Archives</a></li>
            
                <li class="layui-nav-item" id="nav_big"><a href="/about/">About</a></li>
            
                <li class="layui-nav-item" id="nav_big"><a href="/">Home</a></li>
            
        

        
        <li class="layui-nav-item" id="nav_small">
            <a href="javascript:;">
                <i class="layui-icon layui-icon-app" style="font-size: 24px;"></i>
            </a>

            <dl class="layui-nav-child">
                
                <dd><a href="/post/">Posts</a></dd>
                

                
                    
                        <dd><a href="/zone/">Archives</a></dd>
                    
                        <dd><a href="/about/">About</a></dd>
                    
                        <dd><a href="/">Home</a></dd>
                    
                
            </dl>
        </li>
    </ul>
</header>

<script>
layui.use('element', function(){
  var element = layui.element;
});
</script>

        <div id="content" style="min-height:80%">
<div class="layui-container" style="margin-bottom: 10px">
    
    <div class="layui-row layui-col-space10">
        <div class="layui-col-md8 layui-col-sm12 layui-col-xs12">
            <div class="layui-card single-card">
                <br />
                <blockquote class="self-elem-quote self-elem-quote-bg-red markdown-body single-title" >
                    <h1>ORBSLAM2 程式碼解析 - Frame</h1>
                    <h3 style="margin-top:10px; margin-bottom:10px"> 
    <i class="layui-icon layui-icon-date" style="font-size: 28px; vertical-align: -2px;"></i>
    <span>2021-04-28</span>

    
     
    <i class="layui-icon layui-icon-list" style="font-size: 32px; vertical-align: -3px;"></i>
    

    
        <a href="/categories/orbslam2-%e7%a8%8b%e5%bc%8f%e7%a2%bc%e8%a7%a3%e6%9e%90/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">ORBSLAM2 程式碼解析</span>
        </a>
    

    
    <i class="layui-icon layui-icon-tabs" style="font-size: 22px; vertical-align: 1px;margin-right:2px;"></i>
    

    
        <a href="/tags/orbslam2/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">ORBSLAM2</span>
        </a>
    
        <a href="/tags/code-analysis/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">code analysis</span>
        </a>
    
    
</h3>

                </blockquote>
                <div class="layui-card-body markdown-body single-content">
                    <h2 id="system-overview">System Overview</h2>
<p><img src="/ORBSLAM2-img/system-overview.JPG" alt="System Overview"></p>
<h4 id="source-code--linkhttpsgithubcomraulmurorb_slam2">Source Code : <a href="https://github.com/raulmur/ORB_SLAM2">Link</a></h4>
<p>Frame是指幀，也就是對應的圖像，可以是一元、二元或RGBD，所以此類別所包含SLAM中以幀為單位的操作，有以下方面 :</p>
<ul>
<li>讀寫該幀對應的相機位姿</li>
<li>處理幀和特徵點之間的關係，包括判斷特徵點是否在視野內、獲取該幀依定區域內的特徵點、校正特徵點等</li>
<li>恢復深度，如果是RGBD就直接讀取深度值，如果是一元或二元則進行深度恢復</li>
</ul>
<p>以下為Frame類別中的主要函數 :</p>
<pre><code>Frame
│
├── Frame  // 建構函數，有以下五種
├────── 預設建構函數
├────── 複製建構函數
├────── 二元幀建構函數
├────── RGBD幀建構函數
├────── 一元幀建構函數
│
├── ExtractORB  // 提取ORB特徵點
│
├── ComputeBoW  // 計算詞袋數據
│
├── SetPose  // 設置相機位姿參數
│
├── isInFrustum  // 判斷路標點是否在視野中
│
├── GetFeaturesInArea  // 查找特定區域內的特徵點
│
├── ComputeStereoMatches  // 利用二元恢復深度
│
├── ComputeStereoFromRGBD  // RGBD獲取深度訊息
│
├── UnprojectStereo  // 特徵點座標反投影到3D地圖點
</code></pre><h2 id="建構函數">建構函數</h2>
<p>建構函數除了預設與複製之外，其他主要對應三種相機模型，主要功能也類似，就是提取特徵點，然後把特徵點劃分到網格中，使特徵點在圖像中分布較均勻</p>
<p>另外，還有深度問題，RGBD相機本身有深度值直接讀取即可，二元相機需使用SAD來恢復深度，而一元相機無法獲取深度，所以深度值直接為-1，這些都在建構函數中完成</p>
<h4 id="二元相機">二元相機</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">Frame<span style="color:#f92672">::</span>Frame(<span style="color:#66d9ef">const</span> cv<span style="color:#f92672">::</span>Mat <span style="color:#f92672">&amp;</span>imLeft, <span style="color:#66d9ef">const</span> cv<span style="color:#f92672">::</span>Mat <span style="color:#f92672">&amp;</span>imRight, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">double</span> <span style="color:#f92672">&amp;</span>timeStamp, ORBextractor<span style="color:#f92672">*</span> extractorLeft, ORBextractor<span style="color:#f92672">*</span> extractorRight, ORBVocabulary<span style="color:#f92672">*</span> voc, cv<span style="color:#f92672">::</span>Mat <span style="color:#f92672">&amp;</span>K, cv<span style="color:#f92672">::</span>Mat <span style="color:#f92672">&amp;</span>distCoef, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> <span style="color:#f92672">&amp;</span>bf, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> <span style="color:#f92672">&amp;</span>thDepth)
    <span style="color:#f92672">:</span>mpORBvocabulary(voc),mpORBextractorLeft(extractorLeft),mpORBextractorRight(extractorRight), mTimeStamp(timeStamp), mK(K.clone()),mDistCoef(distCoef.clone()), mbf(bf), mThDepth(thDepth),
     mpReferenceKF(<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>KeyFrame<span style="color:#f92672">*&gt;</span>(NULL))
{
    mnId<span style="color:#f92672">=</span>nNextId<span style="color:#f92672">++</span>;

    mnScaleLevels <span style="color:#f92672">=</span> mpORBextractorLeft<span style="color:#f92672">-&gt;</span>GetLevels();
    mfScaleFactor <span style="color:#f92672">=</span> mpORBextractorLeft<span style="color:#f92672">-&gt;</span>GetScaleFactor();
    mfLogScaleFactor <span style="color:#f92672">=</span> log(mfScaleFactor);
    mvScaleFactors <span style="color:#f92672">=</span> mpORBextractorLeft<span style="color:#f92672">-&gt;</span>GetScaleFactors();
    mvInvScaleFactors <span style="color:#f92672">=</span> mpORBextractorLeft<span style="color:#f92672">-&gt;</span>GetInverseScaleFactors();
    mvLevelSigma2 <span style="color:#f92672">=</span> mpORBextractorLeft<span style="color:#f92672">-&gt;</span>GetScaleSigmaSquares();
    mvInvLevelSigma2 <span style="color:#f92672">=</span> mpORBextractorLeft<span style="color:#f92672">-&gt;</span>GetInverseScaleSigmaSquares();

    <span style="color:#75715e">// 同時對左右目提取特徵
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">thread</span> <span style="color:#a6e22e">threadLeft</span>(<span style="color:#f92672">&amp;</span>Frame<span style="color:#f92672">::</span>ExtractORB,<span style="color:#66d9ef">this</span>,<span style="color:#ae81ff">0</span>,imLeft);
    <span style="color:#66d9ef">thread</span> <span style="color:#a6e22e">threadRight</span>(<span style="color:#f92672">&amp;</span>Frame<span style="color:#f92672">::</span>ExtractORB,<span style="color:#66d9ef">this</span>,<span style="color:#ae81ff">1</span>,imRight);
    threadLeft.join();
    threadRight.join();

    N <span style="color:#f92672">=</span> mvKeys.size();

    <span style="color:#75715e">// mvKeys存放提取的特徵點，如果沒有的話則退出
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(mvKeys.empty())
        <span style="color:#66d9ef">return</span>;

    UndistortKeyPoints();  <span style="color:#75715e">// 對特徵點進行畸變校正
</span><span style="color:#75715e"></span>
    ComputeStereoMatches();  <span style="color:#75715e">// 計算左右目之間的匹配，匹配成功的特徵點會計算其深度，深度會存放在mvuRight和mvDepth中
</span><span style="color:#75715e"></span>
    mvpMapPoints <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>MapPoint<span style="color:#f92672">*&gt;</span>(N,<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>MapPoint<span style="color:#f92672">*&gt;</span>(NULL));  <span style="color:#75715e">// 對應的MapPoints 
</span><span style="color:#75715e"></span>    mvbOutlier <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>(N,false);


    <span style="color:#75715e">// 第一次進入或者標定文件發生變化時會使用該函數，重新計算相機相關參數
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(mbInitialComputations)
    {
        ComputeImageBounds(imLeft);

        mfGridElementWidthInv<span style="color:#f92672">=</span><span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(FRAME_GRID_COLS)<span style="color:#f92672">/</span>(mnMaxX<span style="color:#f92672">-</span>mnMinX);
        mfGridElementHeightInv<span style="color:#f92672">=</span><span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(FRAME_GRID_ROWS)<span style="color:#f92672">/</span>(mnMaxY<span style="color:#f92672">-</span>mnMinY);

        fx <span style="color:#f92672">=</span> K.at<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>);
        fy <span style="color:#f92672">=</span> K.at<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>);
        cx <span style="color:#f92672">=</span> K.at<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">2</span>);
        cy <span style="color:#f92672">=</span> K.at<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>);
        invfx <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0f</span><span style="color:#f92672">/</span>fx;
        invfy <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0f</span><span style="color:#f92672">/</span>fy;

        mbInitialComputations<span style="color:#f92672">=</span>false;
    }

    mb <span style="color:#f92672">=</span> mbf<span style="color:#f92672">/</span>fx;

    AssignFeaturesToGrid();  <span style="color:#75715e">// 把特徵點劃分到網格中，可以設置網格內的特徵點上限，使特徵點分布更均勻
</span><span style="color:#75715e"></span>}
</code></pre></div><p>此建構函數輸入參數為</p>
<ul>
<li>const cv::Mat &amp;imLeft  // 左目圖像</li>
<li>const cv::Mat &amp;imRight  // 右目圖像</li>
<li>const double &amp;timeStamp  // 時間戳</li>
<li>ORBextractor* extractorLeft  // 左目提取特徵</li>
<li>ORBextractor* extractorRight  // 右目提取特徵</li>
<li>ORBVocabulary* voc  // 詞袋數據</li>
<li>cv::Mat &amp;K  // 相機內部參數</li>
<li>cv::Mat &amp;distCoef  // 圖像校正參數</li>
<li>const float &amp;bf  // bf = 二元基線 * fx</li>
<li>const float &amp;thDepth  // 深度的閥值，特徵點深度大於或小於此值時，會被分為close與far兩類</li>
</ul>
<h4 id="rgbd相機">RGBD相機</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">Frame<span style="color:#f92672">::</span>Frame(<span style="color:#66d9ef">const</span> cv<span style="color:#f92672">::</span>Mat <span style="color:#f92672">&amp;</span>imGray, <span style="color:#66d9ef">const</span> cv<span style="color:#f92672">::</span>Mat <span style="color:#f92672">&amp;</span>imDepth, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">double</span> <span style="color:#f92672">&amp;</span>timeStamp, ORBextractor<span style="color:#f92672">*</span> extractor,ORBVocabulary<span style="color:#f92672">*</span> voc, cv<span style="color:#f92672">::</span>Mat <span style="color:#f92672">&amp;</span>K, cv<span style="color:#f92672">::</span>Mat <span style="color:#f92672">&amp;</span>distCoef, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> <span style="color:#f92672">&amp;</span>bf, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> <span style="color:#f92672">&amp;</span>thDepth)
    <span style="color:#f92672">:</span>mpORBvocabulary(voc),mpORBextractorLeft(extractor),mpORBextractorRight(<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>ORBextractor<span style="color:#f92672">*&gt;</span>(NULL)),
     mTimeStamp(timeStamp), mK(K.clone()),mDistCoef(distCoef.clone()), mbf(bf), mThDepth(thDepth)
{
    mnId<span style="color:#f92672">=</span>nNextId<span style="color:#f92672">++</span>;

    mnScaleLevels <span style="color:#f92672">=</span> mpORBextractorLeft<span style="color:#f92672">-&gt;</span>GetLevels();
    mfScaleFactor <span style="color:#f92672">=</span> mpORBextractorLeft<span style="color:#f92672">-&gt;</span>GetScaleFactor();   
    mfLogScaleFactor <span style="color:#f92672">=</span> log(mfScaleFactor);
    mvScaleFactors <span style="color:#f92672">=</span> mpORBextractorLeft<span style="color:#f92672">-&gt;</span>GetScaleFactors();
    mvInvScaleFactors <span style="color:#f92672">=</span> mpORBextractorLeft<span style="color:#f92672">-&gt;</span>GetInverseScaleFactors();
    mvLevelSigma2 <span style="color:#f92672">=</span> mpORBextractorLeft<span style="color:#f92672">-&gt;</span>GetScaleSigmaSquares();
    mvInvLevelSigma2 <span style="color:#f92672">=</span> mpORBextractorLeft<span style="color:#f92672">-&gt;</span>GetInverseScaleSigmaSquares();

    ExtractORB(<span style="color:#ae81ff">0</span>,imGray);  <span style="color:#75715e">// 提取特徵點
</span><span style="color:#75715e"></span>
    N <span style="color:#f92672">=</span> mvKeys.size();

    <span style="color:#66d9ef">if</span>(mvKeys.empty())
        <span style="color:#66d9ef">return</span>;

    UndistortKeyPoints();  <span style="color:#75715e">// 對特徵點進行畸變校正
</span><span style="color:#75715e"></span>
    ComputeStereoFromRGBD(imDepth);  <span style="color:#75715e">// 根據像素座標獲得深度訊息，如果存在則保存起來，函數內還計算假想右圖所對應特徵點的橫坐標
</span><span style="color:#75715e"></span>
    mvpMapPoints <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>MapPoint<span style="color:#f92672">*&gt;</span>(N,<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>MapPoint<span style="color:#f92672">*&gt;</span>(NULL));
    mvbOutlier <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>(N,false);

    <span style="color:#66d9ef">if</span>(mbInitialComputations)
    {
        ComputeImageBounds(imGray);

        mfGridElementWidthInv<span style="color:#f92672">=</span><span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(FRAME_GRID_COLS)<span style="color:#f92672">/</span><span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(mnMaxX<span style="color:#f92672">-</span>mnMinX);
        mfGridElementHeightInv<span style="color:#f92672">=</span><span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(FRAME_GRID_ROWS)<span style="color:#f92672">/</span><span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(mnMaxY<span style="color:#f92672">-</span>mnMinY);

        fx <span style="color:#f92672">=</span> K.at<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>);
        fy <span style="color:#f92672">=</span> K.at<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>);
        cx <span style="color:#f92672">=</span> K.at<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">2</span>);
        cy <span style="color:#f92672">=</span> K.at<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>);
        invfx <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0f</span><span style="color:#f92672">/</span>fx;
        invfy <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0f</span><span style="color:#f92672">/</span>fy;

        mbInitialComputations<span style="color:#f92672">=</span>false;
    }

    mb <span style="color:#f92672">=</span> mbf<span style="color:#f92672">/</span>fx;

    AssignFeaturesToGrid();  <span style="color:#75715e">// 把特徵點劃分到網格中
</span><span style="color:#75715e"></span>}
</code></pre></div><p>此建構函數輸入參數為</p>
<ul>
<li>const cv::Mat &amp;imGray  // 灰階圖</li>
<li>const cv::Mat &amp;imDepth  // 深度值</li>
<li>const double &amp;timeStamp  // 時間戳</li>
<li>ORBextractor* extractor  // ORB特徵提取</li>
<li>ORBVocabulary* voc  // 詞袋數據</li>
<li>cv::Mat &amp;K  // 相機內部參數</li>
<li>cv::Mat &amp;distCoef  // 圖像校正參數</li>
<li>const float &amp;bf  // bf = 二元基線 * fx</li>
<li>const float &amp;thDepth  // 深度的閥值，特徵點深度大於或小於此值時，會被分為close與far兩類</li>
</ul>
<h4 id="一元相機">一元相機</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">Frame<span style="color:#f92672">::</span>Frame(<span style="color:#66d9ef">const</span> cv<span style="color:#f92672">::</span>Mat <span style="color:#f92672">&amp;</span>imGray, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">double</span> <span style="color:#f92672">&amp;</span>timeStamp, ORBextractor<span style="color:#f92672">*</span> extractor,ORBVocabulary<span style="color:#f92672">*</span> voc, cv<span style="color:#f92672">::</span>Mat <span style="color:#f92672">&amp;</span>K, cv<span style="color:#f92672">::</span>Mat <span style="color:#f92672">&amp;</span>distCoef, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> <span style="color:#f92672">&amp;</span>bf, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> <span style="color:#f92672">&amp;</span>thDepth)
    <span style="color:#f92672">:</span>mpORBvocabulary(voc),mpORBextractorLeft(extractor),mpORBextractorRight(<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>ORBextractor<span style="color:#f92672">*&gt;</span>(NULL)),
     mTimeStamp(timeStamp), mK(K.clone()),mDistCoef(distCoef.clone()), mbf(bf), mThDepth(thDepth)
{
    mnId<span style="color:#f92672">=</span>nNextId<span style="color:#f92672">++</span>;

    mnScaleLevels <span style="color:#f92672">=</span> mpORBextractorLeft<span style="color:#f92672">-&gt;</span>GetLevels();
    mfScaleFactor <span style="color:#f92672">=</span> mpORBextractorLeft<span style="color:#f92672">-&gt;</span>GetScaleFactor();
    mfLogScaleFactor <span style="color:#f92672">=</span> log(mfScaleFactor);
    mvScaleFactors <span style="color:#f92672">=</span> mpORBextractorLeft<span style="color:#f92672">-&gt;</span>GetScaleFactors();
    mvInvScaleFactors <span style="color:#f92672">=</span> mpORBextractorLeft<span style="color:#f92672">-&gt;</span>GetInverseScaleFactors();
    mvLevelSigma2 <span style="color:#f92672">=</span> mpORBextractorLeft<span style="color:#f92672">-&gt;</span>GetScaleSigmaSquares();
    mvInvLevelSigma2 <span style="color:#f92672">=</span> mpORBextractorLeft<span style="color:#f92672">-&gt;</span>GetInverseScaleSigmaSquares();

    ExtractORB(<span style="color:#ae81ff">0</span>,imGray);

    N <span style="color:#f92672">=</span> mvKeys.size();

    <span style="color:#66d9ef">if</span>(mvKeys.empty())
        <span style="color:#66d9ef">return</span>;

    UndistortKeyPoints();

    <span style="color:#75715e">// 沒有右目，所以值為-1
</span><span style="color:#75715e"></span>    mvuRight <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(N,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
    mvDepth <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(N,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);

    mvpMapPoints <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>MapPoint<span style="color:#f92672">*&gt;</span>(N,<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>MapPoint<span style="color:#f92672">*&gt;</span>(NULL));
    mvbOutlier <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>(N,false);

    <span style="color:#66d9ef">if</span>(mbInitialComputations)
    {
        ComputeImageBounds(imGray);

        mfGridElementWidthInv<span style="color:#f92672">=</span><span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(FRAME_GRID_COLS)<span style="color:#f92672">/</span><span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(mnMaxX<span style="color:#f92672">-</span>mnMinX);
        mfGridElementHeightInv<span style="color:#f92672">=</span><span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(FRAME_GRID_ROWS)<span style="color:#f92672">/</span><span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(mnMaxY<span style="color:#f92672">-</span>mnMinY);

        fx <span style="color:#f92672">=</span> K.at<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>);
        fy <span style="color:#f92672">=</span> K.at<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>);
        cx <span style="color:#f92672">=</span> K.at<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">2</span>);
        cy <span style="color:#f92672">=</span> K.at<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>);
        invfx <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0f</span><span style="color:#f92672">/</span>fx;
        invfy <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0f</span><span style="color:#f92672">/</span>fy;

        mbInitialComputations<span style="color:#f92672">=</span>false;
    }

    mb <span style="color:#f92672">=</span> mbf<span style="color:#f92672">/</span>fx;

    AssignFeaturesToGrid();
}
</code></pre></div><p>此建構函數輸入參數為</p>
<ul>
<li>const cv::Mat &amp;imGray  // 灰階圖</li>
<li>const double &amp;timeStamp  // 時間戳</li>
<li>ORBextractor* extractor  // ORB特徵提取</li>
<li>ORBVocabulary* voc  // 詞袋數據</li>
<li>cv::Mat &amp;K  // 相機內部參數</li>
<li>cv::Mat &amp;distCoef  // 圖像校正參數</li>
<li>const float &amp;bf  // bf = 二元基線 * fx</li>
<li>const float &amp;thDepth  // 深度的閥值，特徵點深度大於或小於此值時，會被分為close與far兩類</li>
</ul>
<h2 id="提取orb特徵點">提取ORB特徵點</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">void</span> Frame<span style="color:#f92672">::</span>ExtractORB(<span style="color:#66d9ef">int</span> flag, <span style="color:#66d9ef">const</span> cv<span style="color:#f92672">::</span>Mat <span style="color:#f92672">&amp;</span>im)
{
    <span style="color:#66d9ef">if</span>(flag<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)
        (<span style="color:#f92672">*</span>mpORBextractorLeft)(im,cv<span style="color:#f92672">::</span>Mat(),mvKeys,mDescriptors);
    <span style="color:#66d9ef">else</span>
        (<span style="color:#f92672">*</span>mpORBextractorRight)(im,cv<span style="color:#f92672">::</span>Mat(),mvKeysRight,mDescriptorsRight);
}
</code></pre></div><p>此函數將OpenCV自身的ORB提取功能多封裝一層，增加一個flag來決定提取左目或右目，進而使用不同的特徵提取器</p>
<h2 id="計算詞袋數據">計算詞袋數據</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">void</span> Frame<span style="color:#f92672">::</span>ComputeBoW()
{
    <span style="color:#66d9ef">if</span>(mBowVec.empty())
    {
        vector<span style="color:#f92672">&lt;</span>cv<span style="color:#f92672">::</span>Mat<span style="color:#f92672">&gt;</span> vCurrentDesc <span style="color:#f92672">=</span> Converter<span style="color:#f92672">::</span>toDescriptorVector(mDescriptors);
        mpORBvocabulary<span style="color:#f92672">-&gt;</span>transform(vCurrentDesc,mBowVec,mFeatVec,<span style="color:#ae81ff">4</span>);
    }
}
</code></pre></div><p>如果沒有輸入已有的詞袋數據，則用當前的描述子重新計算來生成詞袋數據</p>
<h2 id="設置相機位姿參數">設置相機位姿參數</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">void</span> Frame<span style="color:#f92672">::</span>SetPose(cv<span style="color:#f92672">::</span>Mat Tcw)
{
    mTcw <span style="color:#f92672">=</span> Tcw.clone();
    UpdatePoseMatrices();
}

<span style="color:#66d9ef">void</span> Frame<span style="color:#f92672">::</span>UpdatePoseMatrices()
{ 
    mRcw <span style="color:#f92672">=</span> mTcw.rowRange(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">3</span>).colRange(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">3</span>);
    mRwc <span style="color:#f92672">=</span> mRcw.t();
    mtcw <span style="color:#f92672">=</span> mTcw.rowRange(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">3</span>).col(<span style="color:#ae81ff">3</span>);
    mOw <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>mRcw.t()<span style="color:#f92672">*</span>mtcw;
}
</code></pre></div><p>設置相機位姿參數，並計算相機光心的位置</p>
<h2 id="判斷路標點是否在視野中">判斷路標點是否在視野中</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">bool</span> Frame<span style="color:#f92672">::</span>isInFrustum(MapPoint <span style="color:#f92672">*</span>pMP, <span style="color:#66d9ef">float</span> viewingCosLimit)
{
    pMP<span style="color:#f92672">-&gt;</span>mbTrackInView <span style="color:#f92672">=</span> false;

    cv<span style="color:#f92672">::</span>Mat P <span style="color:#f92672">=</span> pMP<span style="color:#f92672">-&gt;</span>GetWorldPos(); 

    <span style="color:#75715e">// 3D點P在相機坐標系下的位置
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> cv<span style="color:#f92672">::</span>Mat Pc <span style="color:#f92672">=</span> mRcw<span style="color:#f92672">*</span>P<span style="color:#f92672">+</span>mtcw;
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> <span style="color:#f92672">&amp;</span>PcX <span style="color:#f92672">=</span> Pc.at<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">0</span>);
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> <span style="color:#f92672">&amp;</span>PcY<span style="color:#f92672">=</span> Pc.at<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> <span style="color:#f92672">&amp;</span>PcZ <span style="color:#f92672">=</span> Pc.at<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">2</span>);

    <span style="color:#66d9ef">if</span>(PcZ<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0.0f</span>)
        <span style="color:#66d9ef">return</span> false;

    <span style="color:#75715e">// 將MapPoint投影到當前的幀
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> invz <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0f</span><span style="color:#f92672">/</span>PcZ;
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> u<span style="color:#f92672">=</span>fx<span style="color:#f92672">*</span>PcX<span style="color:#f92672">*</span>invz<span style="color:#f92672">+</span>cx;
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> v<span style="color:#f92672">=</span>fy<span style="color:#f92672">*</span>PcY<span style="color:#f92672">*</span>invz<span style="color:#f92672">+</span>cy;

    <span style="color:#75715e">// 判斷投影後的坐標是否在圖像中
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(u<span style="color:#f92672">&lt;</span>mnMinX <span style="color:#f92672">||</span> u<span style="color:#f92672">&gt;</span>mnMaxX)
        <span style="color:#66d9ef">return</span> false;
    <span style="color:#66d9ef">if</span>(v<span style="color:#f92672">&lt;</span>mnMinY <span style="color:#f92672">||</span> v<span style="color:#f92672">&gt;</span>mnMaxY)
        <span style="color:#66d9ef">return</span> false;

    <span style="color:#75715e">// 計算MapPoint到相機中心的距離，並判斷是否在尺度變化的距離內
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 每一個地圖點都是從若干尺度的金字塔中提取出來的，具有一定的有效深度
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> maxDistance <span style="color:#f92672">=</span> pMP<span style="color:#f92672">-&gt;</span>GetMaxDistanceInvariance();
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> minDistance <span style="color:#f92672">=</span> pMP<span style="color:#f92672">-&gt;</span>GetMinDistanceInvariance();
    <span style="color:#66d9ef">const</span> cv<span style="color:#f92672">::</span>Mat PO <span style="color:#f92672">=</span> P<span style="color:#f92672">-</span>mOw;
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> dist <span style="color:#f92672">=</span> cv<span style="color:#f92672">::</span>norm(PO);

    <span style="color:#66d9ef">if</span>(dist<span style="color:#f92672">&lt;</span>minDistance <span style="color:#f92672">||</span> dist<span style="color:#f92672">&gt;</span>maxDistance)
        <span style="color:#66d9ef">return</span> false;

    <span style="color:#75715e">// 計算當前視角和平均視角夾角的餘弦值，若小於cos(60°)，即夾角大於60度則返回
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 每一個地圖都有平均視角，能夠從觀測到地圖點的位姿計算出來
</span><span style="color:#75715e"></span>    cv<span style="color:#f92672">::</span>Mat Pn <span style="color:#f92672">=</span> pMP<span style="color:#f92672">-&gt;</span>GetNormal();
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> viewCos <span style="color:#f92672">=</span> PO.dot(Pn)<span style="color:#f92672">/</span>dist;
    <span style="color:#66d9ef">if</span>(viewCos<span style="color:#f92672">&lt;</span>viewingCosLimit)
        <span style="color:#66d9ef">return</span> false;

    <span style="color:#75715e">// 根據深度來預測尺度(對應特徵點在哪一層)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> nPredictedLevel <span style="color:#f92672">=</span> pMP<span style="color:#f92672">-&gt;</span>PredictScale(dist,<span style="color:#66d9ef">this</span>);

    <span style="color:#75715e">// 如果在視野範圍內，由於tracking會用到，因此此處要給值
</span><span style="color:#75715e"></span>    pMP<span style="color:#f92672">-&gt;</span>mbTrackInView <span style="color:#f92672">=</span> true;  <span style="color:#75715e">// 標記位置為true，在函數開頭預設為false
</span><span style="color:#75715e"></span>    pMP<span style="color:#f92672">-&gt;</span>mTrackProjX <span style="color:#f92672">=</span> u;
    pMP<span style="color:#f92672">-&gt;</span>mTrackProjXR <span style="color:#f92672">=</span> u <span style="color:#f92672">-</span> mbf<span style="color:#f92672">*</span>invz;  <span style="color:#75715e">// 該3D點投影到二元右側相機上的橫坐標
</span><span style="color:#75715e"></span>    pMP<span style="color:#f92672">-&gt;</span>mTrackProjY <span style="color:#f92672">=</span> v;
    pMP<span style="color:#f92672">-&gt;</span>mnTrackScaleLevel<span style="color:#f92672">=</span> nPredictedLevel;
    pMP<span style="color:#f92672">-&gt;</span>mTrackViewCos <span style="color:#f92672">=</span> viewCos;

    <span style="color:#66d9ef">return</span> true;
}

</code></pre></div><p>先計算MapPoint在相機坐標系下的位置，用該點與相機光心的連線可知道它在相機的哪個視角範圍內(即該連線與相機正前方的夾角)，如果這角度大於設定值則認為該點不在視野內，反之則在，在的話就計算該MapPoint在該幀圖像上的座標，以便跟踪時使用</p>
<h2 id="查找特定區域內的特徵點">查找特定區域內的特徵點</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">vector<span style="color:#f92672">&lt;</span>size_t<span style="color:#f92672">&gt;</span> Frame<span style="color:#f92672">::</span>GetFeaturesInArea(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> <span style="color:#f92672">&amp;</span>x, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span>  <span style="color:#f92672">&amp;</span>y, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span>  <span style="color:#f92672">&amp;</span>r, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> minLevel, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> maxLevel) <span style="color:#66d9ef">const</span>
{
    vector<span style="color:#f92672">&lt;</span>size_t<span style="color:#f92672">&gt;</span> vIndices;
    vIndices.reserve(N);

    <span style="color:#75715e">// 計算正方形的四邊在網格中的行列數
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// nMinCellX 是正方形左邊在mGrid中的列數，如果大於mGrid的列數的話，表示正方形內沒有特徵點，所以返回
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> nMinCellX <span style="color:#f92672">=</span> max(<span style="color:#ae81ff">0</span>,(<span style="color:#66d9ef">int</span>)floor((x<span style="color:#f92672">-</span>mnMinX<span style="color:#f92672">-</span>r)<span style="color:#f92672">*</span>mfGridElementWidthInv));
    <span style="color:#66d9ef">if</span>(nMinCellX<span style="color:#f92672">&gt;=</span>FRAME_GRID_COLS)
        <span style="color:#66d9ef">return</span> vIndices;

    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> nMaxCellX <span style="color:#f92672">=</span> min((<span style="color:#66d9ef">int</span>)FRAME_GRID_COLS<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,(<span style="color:#66d9ef">int</span>)ceil((x<span style="color:#f92672">-</span>mnMinX<span style="color:#f92672">+</span>r)<span style="color:#f92672">*</span>mfGridElementWidthInv));
    <span style="color:#66d9ef">if</span>(nMaxCellX<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span>)
        <span style="color:#66d9ef">return</span> vIndices;

    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> nMinCellY <span style="color:#f92672">=</span> max(<span style="color:#ae81ff">0</span>,(<span style="color:#66d9ef">int</span>)floor((y<span style="color:#f92672">-</span>mnMinY<span style="color:#f92672">-</span>r)<span style="color:#f92672">*</span>mfGridElementHeightInv));
    <span style="color:#66d9ef">if</span>(nMinCellY<span style="color:#f92672">&gt;=</span>FRAME_GRID_ROWS)
        <span style="color:#66d9ef">return</span> vIndices;

    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> nMaxCellY <span style="color:#f92672">=</span> min((<span style="color:#66d9ef">int</span>)FRAME_GRID_ROWS<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,(<span style="color:#66d9ef">int</span>)ceil((y<span style="color:#f92672">-</span>mnMinY<span style="color:#f92672">+</span>r)<span style="color:#f92672">*</span>mfGridElementHeightInv));
    <span style="color:#66d9ef">if</span>(nMaxCellY<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span>)
        <span style="color:#66d9ef">return</span> vIndices;

    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">bool</span> bCheckLevels <span style="color:#f92672">=</span> (minLevel<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>) <span style="color:#f92672">||</span> (maxLevel<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>);

    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> ix <span style="color:#f92672">=</span> nMinCellX; ix<span style="color:#f92672">&lt;=</span>nMaxCellX; ix<span style="color:#f92672">++</span>)
    {
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> iy <span style="color:#f92672">=</span> nMinCellY; iy<span style="color:#f92672">&lt;=</span>nMaxCellY; iy<span style="color:#f92672">++</span>)
        {
            <span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span>size_t<span style="color:#f92672">&gt;</span> vCell <span style="color:#f92672">=</span> mGrid[ix][iy];
            <span style="color:#66d9ef">if</span>(vCell.empty())
                <span style="color:#66d9ef">continue</span>;

            <span style="color:#66d9ef">for</span>(size_t j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, jend<span style="color:#f92672">=</span>vCell.size(); j<span style="color:#f92672">&lt;</span>jend; j<span style="color:#f92672">++</span>)
            {
                <span style="color:#66d9ef">const</span> cv<span style="color:#f92672">::</span>KeyPoint <span style="color:#f92672">&amp;</span>kpUn <span style="color:#f92672">=</span> mvKeysUn[vCell[j]];
                <span style="color:#66d9ef">if</span>(bCheckLevels)
                {
                    <span style="color:#66d9ef">if</span>(kpUn.octave<span style="color:#f92672">&lt;</span>minLevel)
                        <span style="color:#66d9ef">continue</span>;
                    <span style="color:#66d9ef">if</span>(maxLevel<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>)
                        <span style="color:#66d9ef">if</span>(kpUn.octave<span style="color:#f92672">&gt;</span>maxLevel)
                            <span style="color:#66d9ef">continue</span>;
                }

                <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> distx <span style="color:#f92672">=</span> kpUn.pt.x<span style="color:#f92672">-</span>x;
                <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> disty <span style="color:#f92672">=</span> kpUn.pt.y<span style="color:#f92672">-</span>y;

                <span style="color:#75715e">// 把區域內所有特徵點放入容器中
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span>(fabs(distx)<span style="color:#f92672">&lt;</span>r <span style="color:#f92672">&amp;&amp;</span> fabs(disty)<span style="color:#f92672">&lt;</span>r)
                    vIndices.push_back(vCell[j]);
            }
        }
    }

    <span style="color:#66d9ef">return</span> vIndices;
}
</code></pre></div><p>此函數用來找以x，y為中心，邊長為2r的正方形且在minLevel~maxLevel的特徵點</p>
<h2 id="利用二元恢復深度">利用二元恢復深度</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">void</span> Frame<span style="color:#f92672">::</span>ComputeStereoMatches()
{
    mvuRight <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(N,<span style="color:#f92672">-</span><span style="color:#ae81ff">1.0f</span>);
    mvDepth <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(N,<span style="color:#f92672">-</span><span style="color:#ae81ff">1.0f</span>);

    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> thOrbDist <span style="color:#f92672">=</span> (ORBmatcher<span style="color:#f92672">::</span>TH_HIGH<span style="color:#f92672">+</span>ORBmatcher<span style="color:#f92672">::</span>TH_LOW)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;

    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> nRows <span style="color:#f92672">=</span> mpORBextractorLeft<span style="color:#f92672">-&gt;</span>mvImagePyramid[<span style="color:#ae81ff">0</span>].rows;

    <span style="color:#75715e">// Step 1 : 建立特徵點搜索範圍對應表，一個特徵點在一個帶狀區域內搜索匹配特徵點
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 匹配搜索時，不只在一條橫線上搜索，而是在一條橫向搜索帶上搜索，簡言之，原本每個特徵點的縱座標為1，這裡把特徵點體積放大，縱座標橫跨好幾行
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 例如 : 左目圖像的某個特徵點縱座標為20，那麼右目圖像上搜索時會在縱座標18~22這範圍內搜索，搜索帶範圍為正負2，而搜索帶的寬度與特徵點與所在金字塔層數有關
</span><span style="color:#75715e"></span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span>size_t<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> vRowIndices(nRows,vector<span style="color:#f92672">&lt;</span>size_t<span style="color:#f92672">&gt;</span>());

    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>nRows; i<span style="color:#f92672">++</span>)
        vRowIndices[i].reserve(<span style="color:#ae81ff">200</span>);

    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> Nr <span style="color:#f92672">=</span> mvKeysRight.size();

    <span style="color:#75715e">// 把所有特徵點對應的y值都設置一個搜索帶，然後把搜索帶內所有y座標都和對應的特徵點座標做關聯
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> iR<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; iR<span style="color:#f92672">&lt;</span>Nr; iR<span style="color:#f92672">++</span>)
    {
        <span style="color:#66d9ef">const</span> cv<span style="color:#f92672">::</span>KeyPoint <span style="color:#f92672">&amp;</span>kp <span style="color:#f92672">=</span> mvKeysRight[iR];
        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> <span style="color:#f92672">&amp;</span>kpY <span style="color:#f92672">=</span> kp.pt.y;
        
        <span style="color:#75715e">// 計算匹配搜索帶的縱向寬度，尺度越大(層數越高，距離越近)，搜索帶範圍越大
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 如果特徵點在金字塔第一層時，則搜索範圍為正負2
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 尺度越大旗位置不確定性越高，所以搜索半徑越大
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> r <span style="color:#f92672">=</span> <span style="color:#ae81ff">2.0f</span><span style="color:#f92672">*</span>mvScaleFactors[mvKeysRight[iR].octave];
        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> maxr <span style="color:#f92672">=</span> ceil(kpY<span style="color:#f92672">+</span>r);
        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> minr <span style="color:#f92672">=</span> floor(kpY<span style="color:#f92672">-</span>r);

        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> yi<span style="color:#f92672">=</span>minr;yi<span style="color:#f92672">&lt;=</span>maxr;yi<span style="color:#f92672">++</span>)
            vRowIndices[yi].push_back(iR);
    }

    <span style="color:#75715e">// Set limits for search
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> minZ <span style="color:#f92672">=</span> mb;  <span style="color:#75715e">// Bug : mb沒有初始化，指派mb值的建構函數在ComputeStereoMatches函數後
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> minD <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">// 最小視差，設置為0即可
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> maxD <span style="color:#f92672">=</span> mbf<span style="color:#f92672">/</span>minZ;  <span style="color:#75715e">// 最大視差，對應最小深度，mbf/minZ = mbf/mb = mbf/(mbf/fx) = fx
</span><span style="color:#75715e"></span>
    vector<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> vDistIdx;
    vDistIdx.reserve(N);

    <span style="color:#75715e">// Step 2 : 對左目相機每個特徵點，通過描述子在右目帶狀搜索區域中找到匹配點，再通過SAD做亞像素匹配
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 注意 : 這裡是使用校正前的mvKeys，而不是校正後的mvKeysUn
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 注意 : KeyFrame::UnprojectStereo與Frame::UnprojectStereo是不同的
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> iL<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; iL<span style="color:#f92672">&lt;</span>N; iL<span style="color:#f92672">++</span>)
    {
        <span style="color:#66d9ef">const</span> cv<span style="color:#f92672">::</span>KeyPoint <span style="color:#f92672">&amp;</span>kpL <span style="color:#f92672">=</span> mvKeys[iL];
        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>levelL <span style="color:#f92672">=</span> kpL.octave;
        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> <span style="color:#f92672">&amp;</span>vL <span style="color:#f92672">=</span> kpL.pt.y;
        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> <span style="color:#f92672">&amp;</span>uL <span style="color:#f92672">=</span> kpL.pt.x;

        <span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span>size_t<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>vCandidates <span style="color:#f92672">=</span> vRowIndices[vL];  <span style="color:#75715e">// 可能的匹配點
</span><span style="color:#75715e"></span>
        <span style="color:#66d9ef">if</span>(vCandidates.empty())
            <span style="color:#66d9ef">continue</span>;

        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> minU <span style="color:#f92672">=</span> uL<span style="color:#f92672">-</span>maxD;  <span style="color:#75715e">// 最小匹配範圍
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> maxU <span style="color:#f92672">=</span> uL<span style="color:#f92672">-</span>minD;  <span style="color:#75715e">// 最大匹配範圍
</span><span style="color:#75715e"></span>
        <span style="color:#66d9ef">if</span>(maxU<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span>)
            <span style="color:#66d9ef">continue</span>;

        <span style="color:#66d9ef">int</span> bestDist <span style="color:#f92672">=</span> ORBmatcher<span style="color:#f92672">::</span>TH_HIGH;
        size_t bestIdxR <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

        <span style="color:#66d9ef">const</span> cv<span style="color:#f92672">::</span>Mat <span style="color:#f92672">&amp;</span>dL <span style="color:#f92672">=</span> mDescriptors.row(iL);  <span style="color:#75715e">// 每個特徵點描述子使用一行，建立一個指標指向iL特徵點對應的描述子
</span><span style="color:#75715e"></span>
        <span style="color:#75715e">// Step 2-1 : 尋遍右目所有可能的匹配點，找到最佳匹配點(描述子距離最小)
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(size_t iC<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; iC<span style="color:#f92672">&lt;</span>vCandidates.size(); iC<span style="color:#f92672">++</span>)
        {
            <span style="color:#66d9ef">const</span> size_t iR <span style="color:#f92672">=</span> vCandidates[iC];
            <span style="color:#66d9ef">const</span> cv<span style="color:#f92672">::</span>KeyPoint <span style="color:#f92672">&amp;</span>kpR <span style="color:#f92672">=</span> mvKeysRight[iR];

            <span style="color:#75715e">// 只對鄰近尺度的特徵點進行匹配
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(kpR.octave<span style="color:#f92672">&lt;</span>levelL<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> kpR.octave<span style="color:#f92672">&gt;</span>levelL<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
                <span style="color:#66d9ef">continue</span>;

            <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> <span style="color:#f92672">&amp;</span>uR <span style="color:#f92672">=</span> kpR.pt.x;

            <span style="color:#75715e">// 找出bestIdxR就是最匹配的特徵點，bestDict是該特徵點對應的描述向量距離
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(uR<span style="color:#f92672">&gt;=</span>minU <span style="color:#f92672">&amp;&amp;</span> uR<span style="color:#f92672">&lt;=</span>maxU)
            {
                <span style="color:#66d9ef">const</span> cv<span style="color:#f92672">::</span>Mat <span style="color:#f92672">&amp;</span>dR <span style="color:#f92672">=</span> mDescriptorsRight.row(iR);
                <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dist <span style="color:#f92672">=</span> ORBmatcher<span style="color:#f92672">::</span>DescriptorDistance(dL,dR);

                <span style="color:#66d9ef">if</span>(dist<span style="color:#f92672">&lt;</span>bestDist)
                {
                    bestDist <span style="color:#f92672">=</span> dist;
                    bestIdxR <span style="color:#f92672">=</span> iR;
                }
            }
        }

        <span style="color:#75715e">// Step 2-2 : 通過SAD匹配來提高像素匹配修正量bestincR
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(bestDist<span style="color:#f92672">&lt;</span>thOrbDist)
        {
            <span style="color:#75715e">// kpL.pt.x對應金字塔最底層的座標，將最佳匹配特徵點的尺度轉換到尺度對應層
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> uR0 <span style="color:#f92672">=</span> mvKeysRight[bestIdxR].pt.x;
            <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> scaleFactor <span style="color:#f92672">=</span> mvInvScaleFactors[kpL.octave];
            <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> scaleduL <span style="color:#f92672">=</span> round(kpL.pt.x<span style="color:#f92672">*</span>scaleFactor);
            <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> scaledvL <span style="color:#f92672">=</span> round(kpL.pt.y<span style="color:#f92672">*</span>scaleFactor);
            <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> scaleduR0 <span style="color:#f92672">=</span> round(uR0<span style="color:#f92672">*</span>scaleFactor);

            <span style="color:#75715e">// 滑動窗口大小為11*11
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 注意 : 該窗口取自Resize後的圖像
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
            cv<span style="color:#f92672">::</span>Mat IL <span style="color:#f92672">=</span> mpORBextractorLeft<span style="color:#f92672">-&gt;</span>mvImagePyramid[kpL.octave].rowRange(scaledvL<span style="color:#f92672">-</span>w,scaledvL<span style="color:#f92672">+</span>w<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>).colRange(scaleduL<span style="color:#f92672">-</span>w,scaleduL<span style="color:#f92672">+</span>w<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
            IL.convertTo(IL,CV_32F);
            IL <span style="color:#f92672">=</span> IL <span style="color:#f92672">-</span> IL.at<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(w,w) <span style="color:#f92672">*</span>cv<span style="color:#f92672">::</span>Mat<span style="color:#f92672">::</span>ones(IL.rows,IL.cols,CV_32F);

            <span style="color:#66d9ef">int</span> bestDist <span style="color:#f92672">=</span> INT_MAX;
            <span style="color:#66d9ef">int</span> bestincR <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
            <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> L <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
            vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span> vDists;
            vDists.resize(<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>L<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);

            <span style="color:#75715e">// 滑動窗口的滑動範圍為(-L，L)，提前判斷滑動窗口過程是否發生越界
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> iniu <span style="color:#f92672">=</span> scaleduR0<span style="color:#f92672">+</span>L<span style="color:#f92672">-</span>w;
            <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> endu <span style="color:#f92672">=</span> scaleduR0<span style="color:#f92672">+</span>L<span style="color:#f92672">+</span>w<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
            <span style="color:#66d9ef">if</span>(iniu<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> endu <span style="color:#f92672">&gt;=</span> mpORBextractorRight<span style="color:#f92672">-&gt;</span>mvImagePyramid[kpL.octave].cols)
                <span style="color:#66d9ef">continue</span>;

            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> incR<span style="color:#f92672">=-</span>L; incR<span style="color:#f92672">&lt;=+</span>L; incR<span style="color:#f92672">++</span>)
            {
                <span style="color:#75715e">// 橫向滑動窗口
</span><span style="color:#75715e"></span>                cv<span style="color:#f92672">::</span>Mat IR <span style="color:#f92672">=</span> mpORBextractorRight<span style="color:#f92672">-&gt;</span>mvImagePyramid[kpL.octave].rowRange(scaledvL<span style="color:#f92672">-</span>w,scaledvL<span style="color:#f92672">+</span>w<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>).colRange(scaleduR0<span style="color:#f92672">+</span>incR<span style="color:#f92672">-</span>w,scaleduR0<span style="color:#f92672">+</span>incR<span style="color:#f92672">+</span>w<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
                IR.convertTo(IR,CV_32F);
                
                <span style="color:#75715e">// 窗口中的每個元素減去中心的元素，並歸一化，來減少高照強度的影響
</span><span style="color:#75715e"></span>                IR <span style="color:#f92672">=</span> IR <span style="color:#f92672">-</span> IR.at<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(w,w) <span style="color:#f92672">*</span>cv<span style="color:#f92672">::</span>Mat<span style="color:#f92672">::</span>ones(IR.rows,IR.cols,CV_32F);

                <span style="color:#66d9ef">float</span> dist <span style="color:#f92672">=</span> cv<span style="color:#f92672">::</span>norm(IL,IR,cv<span style="color:#f92672">::</span>NORM_L1);
                <span style="color:#66d9ef">if</span>(dist<span style="color:#f92672">&lt;</span>bestDist)
                {
                    bestDist <span style="color:#f92672">=</span>  dist;  <span style="color:#75715e">// SAD匹配目前最小匹配偏差
</span><span style="color:#75715e"></span>                    bestincR <span style="color:#f92672">=</span> incR;  <span style="color:#75715e">// SAD匹配目前最佳的修正量
</span><span style="color:#75715e"></span>                }

                vDists[L<span style="color:#f92672">+</span>incR] <span style="color:#f92672">=</span> dist;
            }

            <span style="color:#75715e">// 整個滑動過程中，SAD值不是以拋物線形式呈現，則表示SAD匹配失敗，同時放棄求該特徵點深度
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(bestincR<span style="color:#f92672">==-</span>L <span style="color:#f92672">||</span> bestincR<span style="color:#f92672">==</span>L)
                <span style="color:#66d9ef">continue</span>;

            <span style="color:#75715e">// Step 2-3 : 做拋物線擬合來找谷底得到亞像素匹配deltaR
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// bestincR+deltaR就是拋物線谷底的位置
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> dist1 <span style="color:#f92672">=</span> vDists[L<span style="color:#f92672">+</span>bestincR<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
            <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> dist2 <span style="color:#f92672">=</span> vDists[L<span style="color:#f92672">+</span>bestincR];
            <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> dist3 <span style="color:#f92672">=</span> vDists[L<span style="color:#f92672">+</span>bestincR<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];

            <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> deltaR <span style="color:#f92672">=</span> (dist1<span style="color:#f92672">-</span>dist3)<span style="color:#f92672">/</span>(<span style="color:#ae81ff">2.0f</span><span style="color:#f92672">*</span>(dist1<span style="color:#f92672">+</span>dist3<span style="color:#f92672">-</span><span style="color:#ae81ff">2.0f</span><span style="color:#f92672">*</span>dist2));

            <span style="color:#75715e">// 拋物線擬合得到的修正量不能超過一個像素，超過則放氣球該特徵點的深度
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(deltaR<span style="color:#f92672">&lt;-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> deltaR<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span>)
                <span style="color:#66d9ef">continue</span>;

            <span style="color:#75715e">// 通過描述子匹配得到位置為scaleduR0
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 通過SAD匹配找到修正量bestincR
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 通過拋物線擬合找到亞像素修正量deltaR
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">float</span> bestuR <span style="color:#f92672">=</span> mvScaleFactors[kpL.octave]<span style="color:#f92672">*</span>((<span style="color:#66d9ef">float</span>)scaleduR0<span style="color:#f92672">+</span>(<span style="color:#66d9ef">float</span>)bestincR<span style="color:#f92672">+</span>deltaR);

            <span style="color:#66d9ef">float</span> disparity <span style="color:#f92672">=</span> (uL<span style="color:#f92672">-</span>bestuR);

            <span style="color:#75715e">// 判斷視差是否在範圍內
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(disparity<span style="color:#f92672">&gt;=</span>minD <span style="color:#f92672">&amp;&amp;</span> disparity<span style="color:#f92672">&lt;</span>maxD)
            {
                <span style="color:#66d9ef">if</span>(disparity<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">0</span>)
                {
                    disparity<span style="color:#f92672">=</span><span style="color:#ae81ff">0.01</span>;
                    bestuR <span style="color:#f92672">=</span> uL<span style="color:#f92672">-</span><span style="color:#ae81ff">0.01</span>;
                }
                
                <span style="color:#75715e">// 深度 depth = baseline * fx / disparity
</span><span style="color:#75715e"></span>                mvDepth[iL]<span style="color:#f92672">=</span>mbf<span style="color:#f92672">/</span>disparity;  <span style="color:#75715e">// 深度 
</span><span style="color:#75715e"></span>                mvuRight[iL] <span style="color:#f92672">=</span> bestuR;  <span style="color:#75715e">// 匹配在右圖的橫坐標
</span><span style="color:#75715e"></span>                vDistIdx.push_back(pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(bestDist,iL));  <span style="color:#75715e">// 該特徵點SAD匹配最小偏差
</span><span style="color:#75715e"></span>            }
        }
    }

    <span style="color:#75715e">// Step 3 : 去除SAD匹配偏差較大的特徵點
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 之前SAD匹配指判斷滑動窗口是否有局部最小值，這裡會根據對比去除SAD偏差較大特徵點的深度
</span><span style="color:#75715e"></span>    sort(vDistIdx.begin(),vDistIdx.end());  <span style="color:#75715e">// 根據所有匹配對的SAD偏差進行排序，由小到大
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> median <span style="color:#f92672">=</span> vDistIdx[vDistIdx.size()<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>].first;
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> thDist <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.5f</span><span style="color:#f92672">*</span><span style="color:#ae81ff">1.4f</span><span style="color:#f92672">*</span>median;  <span style="color:#75715e">// 計算自適應距離，大於此距離的匹配則會被去除
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>vDistIdx.size()<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">--</span>)
    {
        <span style="color:#66d9ef">if</span>(vDistIdx[i].first<span style="color:#f92672">&lt;</span>thDist)
            <span style="color:#66d9ef">break</span>;
        <span style="color:#66d9ef">else</span>
        {
            mvuRight[vDistIdx[i].second]<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>;
            mvDepth[vDistIdx[i].second]<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>;
        }
    }
}
</code></pre></div><p>此函數是為左圖的每一個特徵點找到在右圖的匹配點，根據基線(有冗餘範圍)上描述子的距離找到匹配，再進行SAD精確定位，最後對所有SAD的值進行排序，去除SAD較大的匹配對，然後利用拋物線擬何來得到亞像素精度的匹配，匹配成功後會更新mvuRight與mvDepth</p>
<h2 id="rgbd獲取深度訊息">RGBD獲取深度訊息</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">void</span> Frame<span style="color:#f92672">::</span>ComputeStereoFromRGBD(<span style="color:#66d9ef">const</span> cv<span style="color:#f92672">::</span>Mat <span style="color:#f92672">&amp;</span>imDepth)
{
    mvuRight <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(N,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
    mvDepth <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(N,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);

    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>N; i<span style="color:#f92672">++</span>)
    {
        <span style="color:#66d9ef">const</span> cv<span style="color:#f92672">::</span>KeyPoint <span style="color:#f92672">&amp;</span>kp <span style="color:#f92672">=</span> mvKeys[i];
        <span style="color:#66d9ef">const</span> cv<span style="color:#f92672">::</span>KeyPoint <span style="color:#f92672">&amp;</span>kpU <span style="color:#f92672">=</span> mvKeysUn[i];

        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> <span style="color:#f92672">&amp;</span>v <span style="color:#f92672">=</span> kp.pt.y;
        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> <span style="color:#f92672">&amp;</span>u <span style="color:#f92672">=</span> kp.pt.x;

        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> d <span style="color:#f92672">=</span> imDepth.at<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(v,u);

        <span style="color:#66d9ef">if</span>(d<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>)
        {
            mvDepth[i] <span style="color:#f92672">=</span> d;
            mvuRight[i] <span style="color:#f92672">=</span> kpU.pt.x<span style="color:#f92672">-</span>mbf<span style="color:#f92672">/</span>d;
        }
    }
}
</code></pre></div><p>根據像素座標獲取深度訊息並保存起來，這裡還計算假想右圖對應特徵點的橫坐標</p>
<h2 id="特徵點座標反投影到3d地圖點">特徵點座標反投影到3D地圖點</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">cv<span style="color:#f92672">::</span>Mat Frame<span style="color:#f92672">::</span>UnprojectStereo(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>i)
{
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> z <span style="color:#f92672">=</span> mvDepth[i];
    <span style="color:#66d9ef">if</span>(z<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>)
    {
        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> u <span style="color:#f92672">=</span> mvKeysUn[i].pt.x;
        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> v <span style="color:#f92672">=</span> mvKeysUn[i].pt.y;
        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> x <span style="color:#f92672">=</span> (u<span style="color:#f92672">-</span>cx)<span style="color:#f92672">*</span>z<span style="color:#f92672">*</span>invfx;
        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> y <span style="color:#f92672">=</span> (v<span style="color:#f92672">-</span>cy)<span style="color:#f92672">*</span>z<span style="color:#f92672">*</span>invfy;
        cv<span style="color:#f92672">::</span>Mat x3Dc <span style="color:#f92672">=</span> (cv<span style="color:#f92672">::</span>Mat_<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">1</span>) <span style="color:#f92672">&lt;&lt;</span> x, y, z);
        <span style="color:#66d9ef">return</span> mRwc<span style="color:#f92672">*</span>x3Dc<span style="color:#f92672">+</span>mOw;
    }
    <span style="color:#66d9ef">else</span>
        <span style="color:#66d9ef">return</span> cv<span style="color:#f92672">::</span>Mat();
}
</code></pre></div><p>此函數作用是將特徵點座標反投影到3D地圖點(世界座標)，在已知深度的情況下，可以確定二維像素對應的尺度，最後獲得3D地圖中的點座標</p>
</div>
            </div>
            
                <script src="https://utteranc.es/client.js"
                    repo="Offliners/MyBlogComments"
                    issue-term="pathname"
                    theme="github-light"
                    crossorigin="anonymous"
                    async>
                </script>
            
        </div>

        <div class="layui-col-md4 layui-col-sm12 layui-col-xs12">
            
            <div class="layui-card single-card">
                <h2 class="single-title">- Table of Contents -</h2>
                <div style="margin-left: 10px;">   
                    <div>

<ul class="toc-h2"><li><a href="/post/orbslam2-code-4/#system-overview">System Overview</a></li>
            <li><a href="/post/orbslam2-code-4/#%e5%bb%ba%e6%a7%8b%e5%87%bd%e6%95%b8">建構函數</a></li>
            <li><a href="/post/orbslam2-code-4/#%e6%8f%90%e5%8f%96orb%e7%89%b9%e5%be%b5%e9%bb%9e">提取ORB特徵點</a></li>
            <li><a href="/post/orbslam2-code-4/#%e8%a8%88%e7%ae%97%e8%a9%9e%e8%a2%8b%e6%95%b8%e6%93%9a">計算詞袋數據</a></li>
            <li><a href="/post/orbslam2-code-4/#%e8%a8%ad%e7%bd%ae%e7%9b%b8%e6%a9%9f%e4%bd%8d%e5%a7%bf%e5%8f%83%e6%95%b8">設置相機位姿參數</a></li>
            <li><a href="/post/orbslam2-code-4/#%e5%88%a4%e6%96%b7%e8%b7%af%e6%a8%99%e9%bb%9e%e6%98%af%e5%90%a6%e5%9c%a8%e8%a6%96%e9%87%8e%e4%b8%ad">判斷路標點是否在視野中</a></li>
            <li><a href="/post/orbslam2-code-4/#%e6%9f%a5%e6%89%be%e7%89%b9%e5%ae%9a%e5%8d%80%e5%9f%9f%e5%85%a7%e7%9a%84%e7%89%b9%e5%be%b5%e9%bb%9e">查找特定區域內的特徵點</a></li>
            <li><a href="/post/orbslam2-code-4/#%e5%88%a9%e7%94%a8%e4%ba%8c%e5%85%83%e6%81%a2%e5%be%a9%e6%b7%b1%e5%ba%a6">利用二元恢復深度</a></li>
            <li><a href="/post/orbslam2-code-4/#rgbd%e7%8d%b2%e5%8f%96%e6%b7%b1%e5%ba%a6%e8%a8%8a%e6%81%af">RGBD獲取深度訊息</a></li>
            <li><a href="/post/orbslam2-code-4/#%e7%89%b9%e5%be%b5%e9%bb%9e%e5%ba%a7%e6%a8%99%e5%8f%8d%e6%8a%95%e5%bd%b1%e5%88%b03d%e5%9c%b0%e5%9c%96%e9%bb%9e">特徵點座標反投影到3D地圖點</a></li>
            </div>
                </div>
            </div>
            

            
            <div class="layui-card single-card">
                <h2 class="single-title">- Relevant Topics -</h2>
                
                	
                    <div style="margin-left: 10px;">
                        <blockquote class="self-elem-quote self-elem-quote-bg-red" style="background-color:#FFFFFF;margin-top: 10px;">
                            <a href="/post/orbslam2-code-3/">
                                <h3 class="">ORBSLAM2 程式碼解析 - MapPoint</h3>
                            </a>
                            <h3 style="margin-top:10px; margin-bottom:10px"> 
    <i class="layui-icon layui-icon-date" style="font-size: 28px; vertical-align: -2px;"></i>
    <span>2021-04-28</span>

    
     
    <i class="layui-icon layui-icon-list" style="font-size: 32px; vertical-align: -3px;"></i>
    

    
        <a href="/categories/orbslam2-%e7%a8%8b%e5%bc%8f%e7%a2%bc%e8%a7%a3%e6%9e%90/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">ORBSLAM2 程式碼解析</span>
        </a>
    

    
    <i class="layui-icon layui-icon-tabs" style="font-size: 22px; vertical-align: 1px;margin-right:2px;"></i>
    

    
        <a href="/tags/orbslam2/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">ORBSLAM2</span>
        </a>
    
        <a href="/tags/code-analysis/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">code analysis</span>
        </a>
    
    
</h3>

                        </blockquote>
                    </div>
                	
                    <div style="margin-left: 10px;">
                        <blockquote class="self-elem-quote self-elem-quote-bg-red" style="background-color:#FFFFFF;margin-top: 10px;">
                            <a href="/post/orbslam2-code-2/">
                                <h3 class="">ORBSLAM2 程式碼解析 - System</h3>
                            </a>
                            <h3 style="margin-top:10px; margin-bottom:10px"> 
    <i class="layui-icon layui-icon-date" style="font-size: 28px; vertical-align: -2px;"></i>
    <span>2021-04-27</span>

    
     
    <i class="layui-icon layui-icon-list" style="font-size: 32px; vertical-align: -3px;"></i>
    

    
        <a href="/categories/orbslam2-%e7%a8%8b%e5%bc%8f%e7%a2%bc%e8%a7%a3%e6%9e%90/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">ORBSLAM2 程式碼解析</span>
        </a>
    

    
    <i class="layui-icon layui-icon-tabs" style="font-size: 22px; vertical-align: 1px;margin-right:2px;"></i>
    

    
        <a href="/tags/orbslam2/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">ORBSLAM2</span>
        </a>
    
        <a href="/tags/code-analysis/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">code analysis</span>
        </a>
    
    
</h3>

                        </blockquote>
                    </div>
                	
                    <div style="margin-left: 10px;">
                        <blockquote class="self-elem-quote self-elem-quote-bg-red" style="background-color:#FFFFFF;margin-top: 10px;">
                            <a href="/post/orbslam2-code-1/">
                                <h3 class="">ORBSLAM2 程式碼解析 - 論文閱讀</h3>
                            </a>
                            <h3 style="margin-top:10px; margin-bottom:10px"> 
    <i class="layui-icon layui-icon-date" style="font-size: 28px; vertical-align: -2px;"></i>
    <span>2021-04-17</span>

    
     
    <i class="layui-icon layui-icon-list" style="font-size: 32px; vertical-align: -3px;"></i>
    

    
        <a href="/categories/orbslam2-%e7%a8%8b%e5%bc%8f%e7%a2%bc%e8%a7%a3%e6%9e%90/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">ORBSLAM2 程式碼解析</span>
        </a>
    

    
    <i class="layui-icon layui-icon-tabs" style="font-size: 22px; vertical-align: 1px;margin-right:2px;"></i>
    

    
        <a href="/tags/orbslam2/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">ORBSLAM2</span>
        </a>
    
        <a href="/tags/code-analysis/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">code analysis</span>
        </a>
    
    
</h3>

                        </blockquote>
                    </div>
                	
                    <div style="margin-left: 10px;">
                        <blockquote class="self-elem-quote self-elem-quote-bg-red" style="background-color:#FFFFFF;margin-top: 10px;">
                            <a href="/post/orbslam2-build/">
                                <h3 class="">ORBSLAM2 Build on Windows 10</h3>
                            </a>
                            <h3 style="margin-top:10px; margin-bottom:10px"> 
    <i class="layui-icon layui-icon-date" style="font-size: 28px; vertical-align: -2px;"></i>
    <span>2021-04-01</span>

    
     
    <i class="layui-icon layui-icon-list" style="font-size: 32px; vertical-align: -3px;"></i>
    

    
        <a href="/categories/%e7%92%b0%e5%a2%83%e5%bb%ba%e7%ab%8b/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">環境建立</span>
        </a>
    

    
    <i class="layui-icon layui-icon-tabs" style="font-size: 22px; vertical-align: 1px;margin-right:2px;"></i>
    

    
        <a href="/tags/orbslam2/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">ORBSLAM2</span>
        </a>
    
        <a href="/tags/cmake/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">CMake</span>
        </a>
    
        <a href="/tags/visual-studio-2015/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">Visual Studio 2015</span>
        </a>
    
        <a href="/tags/opencv/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">OpenCV</span>
        </a>
    
    
</h3>

                        </blockquote>
                    </div>
                	
                
                <br />
            </div>
            

            <div class="layui-card single-card">
                <h2 class="single-title">- Recent Posts -</h2>
            
                
                <div style="margin-left: 10px;">
                    <blockquote class="self-elem-quote self-elem-quote-bg-red" style="background-color:#FFFFFF;margin-top: 10px;">
                    <a href="/post/ntuml-week14-1/">
                        <h3 class="">NTU Machine Learning Week 14 - Domain Adaptation</h3>
                    </a>
                    <h3 style="margin-top:10px; margin-bottom:10px"> 
    <i class="layui-icon layui-icon-date" style="font-size: 28px; vertical-align: -2px;"></i>
    <span>2021-05-24</span>

    
     
    <i class="layui-icon layui-icon-list" style="font-size: 32px; vertical-align: -3px;"></i>
    

    
        <a href="/categories/ntu-%e6%a9%9f%e5%99%a8%e5%ad%b8%e7%bf%92-note/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">NTU 機器學習 note</span>
        </a>
    

    
    <i class="layui-icon layui-icon-tabs" style="font-size: 22px; vertical-align: 1px;margin-right:2px;"></i>
    

    
        <a href="/tags/machine-learning/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">Machine Learning</span>
        </a>
    
        <a href="/tags/deep-learning/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">Deep Learning</span>
        </a>
    
        <a href="/tags/ntu-ml-2021/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">NTU ML 2021</span>
        </a>
    
    
</h3>

                    </blockquote>
                </div>
                
                <div style="margin-left: 10px;">
                    <blockquote class="self-elem-quote self-elem-quote-bg-red" style="background-color:#FFFFFF;margin-top: 10px;">
                    <a href="/post/ntuml-week13/">
                        <h3 class="">NTU Machine Learning Week 13 - Explainable AI</h3>
                    </a>
                    <h3 style="margin-top:10px; margin-bottom:10px"> 
    <i class="layui-icon layui-icon-date" style="font-size: 28px; vertical-align: -2px;"></i>
    <span>2021-05-16</span>

    
     
    <i class="layui-icon layui-icon-list" style="font-size: 32px; vertical-align: -3px;"></i>
    

    
        <a href="/categories/ntu-%e6%a9%9f%e5%99%a8%e5%ad%b8%e7%bf%92-note/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">NTU 機器學習 note</span>
        </a>
    

    
    <i class="layui-icon layui-icon-tabs" style="font-size: 22px; vertical-align: 1px;margin-right:2px;"></i>
    

    
        <a href="/tags/machine-learning/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">Machine Learning</span>
        </a>
    
        <a href="/tags/deep-learning/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">Deep Learning</span>
        </a>
    
        <a href="/tags/ntu-ml-2021/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">NTU ML 2021</span>
        </a>
    
    
</h3>

                    </blockquote>
                </div>
                
                <div style="margin-left: 10px;">
                    <blockquote class="self-elem-quote self-elem-quote-bg-red" style="background-color:#FFFFFF;margin-top: 10px;">
                    <a href="/post/ntuml-week11/">
                        <h3 class="">NTU Machine Learning Week 11 - Adversarial Attack</h3>
                    </a>
                    <h3 style="margin-top:10px; margin-bottom:10px"> 
    <i class="layui-icon layui-icon-date" style="font-size: 28px; vertical-align: -2px;"></i>
    <span>2021-05-15</span>

    
     
    <i class="layui-icon layui-icon-list" style="font-size: 32px; vertical-align: -3px;"></i>
    

    
        <a href="/categories/ntu-%e6%a9%9f%e5%99%a8%e5%ad%b8%e7%bf%92-note/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">NTU 機器學習 note</span>
        </a>
    

    
    <i class="layui-icon layui-icon-tabs" style="font-size: 22px; vertical-align: 1px;margin-right:2px;"></i>
    

    
        <a href="/tags/machine-learning/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">Machine Learning</span>
        </a>
    
        <a href="/tags/deep-learning/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">Deep Learning</span>
        </a>
    
        <a href="/tags/ntu-ml-2021/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">NTU ML 2021</span>
        </a>
    
    
</h3>

                    </blockquote>
                </div>
                
                <div style="margin-left: 10px;">
                    <blockquote class="self-elem-quote self-elem-quote-bg-red" style="background-color:#FFFFFF;margin-top: 10px;">
                    <a href="/post/ntuml-week10/">
                        <h3 class="">NTU Machine Learning Week 10 - Auto-Encoder</h3>
                    </a>
                    <h3 style="margin-top:10px; margin-bottom:10px"> 
    <i class="layui-icon layui-icon-date" style="font-size: 28px; vertical-align: -2px;"></i>
    <span>2021-05-01</span>

    
     
    <i class="layui-icon layui-icon-list" style="font-size: 32px; vertical-align: -3px;"></i>
    

    
        <a href="/categories/ntu-%e6%a9%9f%e5%99%a8%e5%ad%b8%e7%bf%92-note/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">NTU 機器學習 note</span>
        </a>
    

    
    <i class="layui-icon layui-icon-tabs" style="font-size: 22px; vertical-align: 1px;margin-right:2px;"></i>
    

    
        <a href="/tags/machine-learning/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">Machine Learning</span>
        </a>
    
        <a href="/tags/deep-learning/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">Deep Learning</span>
        </a>
    
        <a href="/tags/ntu-ml-2021/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">NTU ML 2021</span>
        </a>
    
    
</h3>

                    </blockquote>
                </div>
                
                <div style="margin-left: 10px;">
                    <blockquote class="self-elem-quote self-elem-quote-bg-red" style="background-color:#FFFFFF;margin-top: 10px;">
                    <a href="/post/orbslam2-code-4/">
                        <h3 class="">ORBSLAM2 程式碼解析 - Frame</h3>
                    </a>
                    <h3 style="margin-top:10px; margin-bottom:10px"> 
    <i class="layui-icon layui-icon-date" style="font-size: 28px; vertical-align: -2px;"></i>
    <span>2021-04-28</span>

    
     
    <i class="layui-icon layui-icon-list" style="font-size: 32px; vertical-align: -3px;"></i>
    

    
        <a href="/categories/orbslam2-%e7%a8%8b%e5%bc%8f%e7%a2%bc%e8%a7%a3%e6%9e%90/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">ORBSLAM2 程式碼解析</span>
        </a>
    

    
    <i class="layui-icon layui-icon-tabs" style="font-size: 22px; vertical-align: 1px;margin-right:2px;"></i>
    

    
        <a href="/tags/orbslam2/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">ORBSLAM2</span>
        </a>
    
        <a href="/tags/code-analysis/">
            <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">code analysis</span>
        </a>
    
    
</h3>

                    </blockquote>
                </div>
                
            
            <br />
            </div>
        </div>
    </div>
    
    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WFQ2VM3C00"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-WFQ2VM3C00');
</script>
    
</div>

        </div><footer>
    

    <div class="layui-container">
        <div class="layui-row">
            <div class="layui-col-md4 layui-col-sm6 layui-col-xs6">
            </div>
        </div>
        <div class="layui-row">
            
            <div class="layui-col-md4 layui-col-sm6 layui-col-xs12">
                <a href="/zone/"><p class="footer-url">Archives</p></a>
            </div>
            
            <div class="layui-col-md4 layui-col-sm6 layui-col-xs12">
                <a href="/about/"><p class="footer-url">About</p></a>
            </div>
            
            <div class="layui-col-md4 layui-col-sm6 layui-col-xs12">
                <a href="/"><p class="footer-url">Home</p></a>
            </div>
            
        </div>
    </div>
    
    
    <div class="layui-container">
        <p class="copyright">&copy; All rights reserved. Powered by <a href='https://gohugo.io' style='color:#FFFFFF'>Hugo</a> and <a href='https://github.com/ertuil/erblog' style='color:#FFFFFF'>Erblog</a>.</p>
    </div>
</footer>

</body>
</html>
